<!DOCTYPE>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8">
	<title>Feedback on implementing the proposed std::error type</title>

	<style>
	p {text-align:justify}
	li {text-align:justify}
	blockquote.note
	{
		background-color:#E0E0E0;
		padding-left: 15px;
		padding-right: 15px;
		padding-top: 1px;
		padding-bottom: 1px;
	}
	tab { padding-left: 2em; }
    tab2 { padding-left: 4em; }
	ins {background-color:#A0FFA0}
	del {background-color:#FFA0A0}
   tt {color:#05526b}
   td { color:#3b3935; padding-left: 1em; padding-top:0.2em; padding-bottom: 0.2em;}

	.e1 { color:#05526b; font-weight: bold; } 
	.e2 { color:#940909; font-weight: bold; }
	</style>
</head>
<body>

<address align="right">
<br>
<a href="mailto:charles.a.salvia@gmail.com">Charles Salvia</a><br>
2020-05-10<br>
</address>

<h1 align="center">Feedback on implementing the proposed std::error type</h1>

<h2>Abstract</h2>

<p>
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0709r4.pdf">P0709</a>] proposes 
<tt>std::error</tt> as a mechanism for supporting deterministic 
static exceptions, as well as a more powerful successor to
<tt>std::error_code</tt>.  I've implemented the proposed <tt>std::error</tt>, including support
for treating <tt>std::exception_ptr</tt> as a <i>TriviallyRelocatable</i> type that can be
transported via an <tt>std::error</tt> object without performing an allocation.  In this paper
I provide feedback on the overall design of <tt>std::error</tt>, particularly with regard to
how it might map to "legacy" error mechanisms such as dynamic exceptions and/or <tt>std::error_code</tt>, 
and also provide some discussion and rationale around design decisions and trade-offs I made while implementing
<tt>std::error</tt> that differ from the current <tt>status_code</tt> based implementation proposed in 
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1028r3.pdf">P1028</a>].
</p>

<p>
This paper does not propose anything fundamentally different from [<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0709r4.pdf">P0709</a>],
but merely explores certain design considerations and trade-offs that surface when implementing <tt>std::error</tt> and suggests 
what a minimal specification should probably contain based on actual
implementation experience, while also discussing considerations that arise when attempting to map <tt>std::error</tt>
to "legacy" error mechanisms such as dynamic exceptions and <tt>std::error_code</tt>.  Finally, this paper is focused
only on the design and implementation of the <tt>std::error</tt> type and how it maps to existing error facilities - 
this paper does <i>not</i> address the larger issue of deterministic static exceptions.
</p>
<p>
The implementation of <tt>std::error</tt> discussed here is available at:
<blockquote>
Repos link: <a href="https://github.com/charles-salvia/std_error">github.com/charles-salvia/std_error</a>
<br>
All-in-one header-only link: <a href="https://github.com/charles-salvia/std_error/blob/master/all_in_one.hpp">github.com/charles-salvia/std_error/blob/master/all_in_one.hpp</a>
<br>
Example usage/godbolt link: <a href="https://godbolt.org/z/8o1Yg6">https://godbolt.org/z/8o1Yg6</a>
</blockquote>
The implementation requires at least C++14.  It has been tested on GCC 4.9.2 to GCC 10, Clang 4 thru Clang 10, and MSVC 19.14 thru 19.24.
</p>
<h2>Design constraints</h2>
<h3>Trivial Relocation</h3>
<p>
A key feature of the proposed <tt>std::error</tt> is that an instance should be no larger than
two pointers.  An <tt>std::error</tt> therefore consists of a pointer-sized type-erased object,
and a constant pointer to a domain instance.  This is similar to <tt>std::error_code</tt>, where
we have an integral type code along with a pointer to an <tt>std::error_category</tt>, except
<tt>std::error</tt> contains a type-erased object that could potentially represent any arbitrarily
rich data.  It's up to the <tt>error_domain</tt> object to decide how to statically cast the type-erased data to the
appropriate type.
</p>
<p>
One important requirement of any type <tt>T</tt> that is to be type-erased and stored within an <tt>std::error</tt>
is that <tt>T</tt> must be <i>TriviallyRelocatable</i>, meaning essentially that move-constructing an instance of <tt>T</tt>
must be functionally equivalent to simply doing a bitwise copy and then replacing the moved-from instance with <tt>T{}</tt>.  
Both <tt>std::unique_ptr</tt> and <tt>std::shared_ptr</tt> could fit this requirement conceptually, as could <tt>std::exception_ptr</tt>.
</p>
<p>
An <tt>std::error</tt> object could then easily contain either an integral-type error code, or arbitrarily rich information passed
in as a type-erased smart pointer which would be <i>move-relocated</i> into the pointer-sized storage contained in the
<tt>std::error</tt> object.  An <tt>std::exception_ptr</tt>, if implemented such that it is no larger than a raw pointer, could also
be transported efficiently in an <tt>std::error</tt>.
</p>

<p>
However, being able to transport a type-erased smart pointer such as <tt>std::exception_ptr</tt> immediately brings up
certain design decisions that need to be considered up-front.  For example, as a type-erasing transport for arbitrary
<i>TriviallyRelocatable</i> types, <tt>std::error</tt> must at the very least have access to a polymorphic destructor
function that can invoke the destructor of the erased type.  If we limit <tt>std::error</tt> itself to being 
<i>TriviallyRelocatable</i> with a deleted copy constructor, we do not need to provide any additional polymorphic 
functions to manage the erased type, apart from the destructor.
</p>
<p>
For example, in order to transport a move-only object like a <tt>unique_ptr</tt>,
we would <i>move-relocate</i> the <tt>unique_ptr</tt> instance into type-erased storage, and then simply bitwise-copy the type-erased
storage an arbitrary number of times until the last move-constructed instance is destructed, at which point we'd need to call
a polymorphic destructor that has knowledge of the erased type (implemented perhaps as a virtual function in the <tt>error_domain</tt>). We can 
set the internal <tt>error_domain</tt> pointer of a moved-from <tt>std::error</tt> instance to <tt>nullptr</tt> to disable destructors 
of moved-from error objects.  This is how the <tt>status_code</tt> based implementation of <tt>std::error</tt> proposed in
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1028r3.pdf">P1028</a>] is implemented.
This design also requires that <tt>std::error</tt> itself is move-only.
</p>

<h3>Is std::error move-only?</h3>
<p>
Should <tt>std::error</tt> be required to be move-only?  The original proposal 
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0709r4.pdf">P0709</a>] doesn't explicitly say that
<tt>std::error</tt> is move-only; rather, it only specifies that <tt>std::error</tt> should be trivially relocatable.  However,
this doesn't necessarily mean <tt>std::error</tt> must be move-only.  A generic copy constructor for some erased type <tt>T</tt> could
be safely implemented by copy-constructing a temporary, and then move-relocating it into the destination storage.  Regardless, the current
<tt>status_code</tt> based implementation of <tt>std::error</tt> proposed in 
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1028r3.pdf">P1028</a>] is indeed
move-only, but provides a <tt>clone()</tt> function for explicitly copying an error instance.
</p>

<p>
The implementation of <tt>std::error</tt> submitted here is both trivially-relocatable and copy-constructible.  (Note that many
trivially relocatable types are copy-constructible, but not <i>trivially</i> copy-constructible, such as <tt>std::shared_ptr</tt>.)
Implementing a copy-constructible version of <tt>std::error</tt> requires that we call the copy-constructor of the type-erased object each time
the <tt>std::error</tt> object itself is copied.  This can be efficiently
implemented by providing the <tt>error_domain</tt> instance with three function pointers - a copy constructor, move constructor,
and destructor.  (Again, the copy construction would need to be implemented in terms of a copy, followed by a move-relocate.) Error domains that use 
trivially-copyable types, such as enums or integral types, can set the function pointers to <tt>nullptr</tt>.  Since error domains are expected
to be <tt>constexpr</tt>, the call to the copy/move-constructor or destructor can be optimized out, and since statically thrown errors are
essentially return-by-value, copying would be elided very often anyway.
</p>

<p>
Regardless, it remains an open question whether <tt>std::error</tt> should be copy-constructible.  As a general replacement for
both <tt>std::error_code</tt> as well as dynamic exceptions, it seems we should default to allowing <tt>std::error</tt> to support copy
construction unless there is a very compelling reason not to.  Both <tt>std::error_code</tt> and <tt>std::exception_ptr</tt> are copy-constructible, 
and there seems no reason to limit <tt>std::error</tt> to being move-only, apart from the requirement that any type-erased object used 
with <tt>std::error</tt> would need to be trivially-relocatable <i>and</i> copy-constructible.  This rules out <tt>std::unique_ptr</tt>, 
but allows <tt>std::exception_ptr</tt>.
</p>

<p>
As a general mechanism for conveniently transporting arbitrary data via a copy-constructible <tt>std::error</tt>, it would be nice to be able to easily
store a type-erased reference counted smart pointer.  Unfortunately, we cannot directly store an <tt>std::shared_ptr</tt> in
the single-pointer-sized storage provided by <tt>std::error</tt>, since a <tt>std::shared_ptr</tt> implementation typically requires at least
2 pointers due to aliasing support (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2351.htm#aliasing">N2351</a>).  Rather, we would 
need a simpler reference counting smart pointer type, perhaps using intrusive reference counting, so that it could fit into single-pointer-sized 
storage.  (The implementation presented here includes a reference-counting intrusive smart pointer to demonstrate transporting arbitrary data via
an <tt>std::error</tt>).  Note that we don't have the same problem with <tt>std::exception_ptr</tt>, which can be implemented as a move-relocatable
type with single-pointer size, and in fact is single-pointer-size in mainstream implementations such as libstdc++.
</p>

<p>

</p>

<h2>Mapping "Legacy" Error Mechanisms to std::error</h2>

<p>
<h3>Mapping std::error_code to std::error</h3>
<p>
The original proposal [<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0709r4.pdf">P0709</a>] discusses mapping standard 
dynamic exception types to <tt>std::error</tt>, and also implies that <tt>std::errc</tt> enums will be inherited from <tt>&lt;system_error&gt;</tt> to 
represent a "generic" domain of errors.  However, it doesn't discuss mapping an arbitrary <tt>std::error_code</tt> to an <tt>std::error</tt>
object.  Presumably, in the interest of easing adoption of <tt>std::error</tt>, we would want any possible <tt>std::error_code</tt> to be 
convertible to an <tt>std::error</tt>. 
</p>
<p>
We can efficiently convert <tt>std::error_code</tt> objects that use standard error categories to an <tt>std::error</tt> by simply providing 
matching <tt>error_domain</tt> objects for each <tt>error_category</tt>.  Perhaps we would have a <tt>generic_domain</tt> that represents
error values using <tt>std::errc</tt>, exactly like <tt>std::generic_category()</tt> does now.
</p>
<p>
Additionally, we can efficiently convert any <tt>ErrorCodeEnum</tt> (an enum type that specializes the <tt>std::is_error_code_enum</tt> template) to
an <tt>std::error</tt>.  This would require storing the enum in the type-erased error storage, and creating a special error domain for error
code enums.  We could determine the <tt>std::error_category</tt> instance associated with the <tt>ErrorCodeEnum</tt> on the fly as needed via 
ADL and the <tt>make_error_code</tt> customization point.  We wouldn't need to store the <tt>std::error_category</tt> in the error storage - we 
could just produce it on demand with <tt>make_error_code</tt> in order to implement weak-equality comparison or produce an error message.
</p>
<p>
However, we cannot efficiently represent an arbitrary <tt>std::error_code</tt> object that may potentially have any arbitrary
custom <tt>error_category</tt>.  We need at least 2 pointers worth of storage to represent an arbitrary <tt>std::error_code</tt> - one 
for the code itself and the other for a pointer to the <tt>error_category</tt>.  Since we only have one pointer worth of storage in
an <tt>std::error</tt>, we'd need a heap allocation to map an arbitrary <tt>std::error_code</tt> to an <tt>std::error</tt>.  The implementation
submitted here provides matching error domains for standard categories (such as <tt>std::generic_category</tt>), and uses heap allocation
managed by a reference counted pointer to store <tt>std::error_code</tt>s with custom categories in an <tt>std::error</tt> object.
</p>
<p>
Finally, an <tt>std::error_code</tt> may potentially store a zero-value <tt>ErrorCodeEnum</tt> to represent "not an error", whereas
an <tt>std::error</tt> <i>always</i> represents an error.  If we want to provide mappings between <tt>std::error_code</tt> and <tt>std::error</tt>
we essentially have two choices to handle "not an error" error codes.  We can either consider it Undefined Behavior (in the same way that
throwing a null <tt>std::exception_ptr</tt> is undefined behavior), or more preferably, we map it to a special error code/domain that represents
an invalid error, such as <tt>errc::bad_error</tt>.
</p>
<h3>Mapping dynamic exceptions to std::error</h3>
<p>
The original proposal [<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0709r4.pdf">P0709</a>] discusses mapping standard 
dynamic exception types to <tt>std::error</tt>.  Note that when we talk about mapping a dynamic exception to an <tt>std::error</tt>, we're mostly
talking about doing so in the context of a weak-equality (semantic-equivalence) comparison.  An <tt>std::error</tt> can <i>directly</i> store an <tt>std::exception_ptr</tt>,
so there's no need to perform any "mapping" at all for the purposes of simply converting a dynamic exception to an <tt>std::error</tt>.  However,
we probably want to be able to use the <tt>==</tt> operator to perform a semantic comparison with an <tt>std::error</tt> against a set of generic enums
such as <tt>std::errc</tt>.
</p>
<p>
In this context, it would be useful to map, for example, <tt>std::bad_alloc</tt> to <tt>std::errc::not_enough_memory</tt>, so that a dynamic exception
converted to an <tt>std::error</tt> can be tested for weak-equality or semantic equivalence.  The original proposal mentions the need to standardize these mappings.  
</p>
<p>
It turns out that providing mappings from the generic set of <tt>std::errc</tt> enums to the set of standard C++ dynamic exceptions is 
not easy to do in a way that results in particularly useful error mappings.  At first glance it may seem promising: we can map <tt>std::invalid_argument</tt>
to <tt>std::errc::invalid_argument</tt> of course, <tt>std::bad_alloc</tt> to <tt>std::errc::not_enough_memory</tt>, and <tt>std::domain_error</tt> to 
<tt>std::errc::argument_out_of_domain</tt>.
</p>
<p>
The <a href="https://ned14.github.io/status-code/">documentation</a> for the <tt>status_code</tt> based implementation of <tt>std::error</tt>
suggests the following mappings:
</p>
<table>
<tr><td>std::invalid_argument</td><td>&#x2192;</td><td>errc::invalid_argument</td></tr>
<tr><td>std::domain_error</td><td>&#x2192;</td><td>errc::argument_out_of_domain</td></tr>
<tr><td>std::length_error</td><td>&#x2192;</td><td>errc::argument_list_too_long</td></tr>
<tr><td>std::out_of_range</td><td>&#x2192;</td><td>errc::result_out_of_range</td></tr>
<tr><td>std::logic_error</td><td>&#x2192;</td><td>errc::invalid_argument</td></tr>
<tr><td>std::overflow_error</td><td>&#x2192;</td><td>errc::value_too_large</td></tr>
<tr><td>std::range_error</td><td>&#x2192;</td><td>errc::result_out_of_range</td></tr>
<tr><td>std::runtime_error</td><td>&#x2192;</td><td>errc::resource_unavailable_try_again</td></tr>
<tr><td>std::bad_alloc</td><td>&#x2192;</td><td>errc::not_enough_memory</td></tr>
</table>
<p>
The implementation submitted here suggests a slightly modified mapping.  However, both mappings are incomplete and there are some highly questionable
mapping choices here such as <tt>std::runtime_error</tt> &#x2192; <tt>errc::resource_unavailable_try_again</tt>.  Additionally, this only provides mappings
for standard exceptions included under <tt>&lt;stdexcept&gt;</tt>.  But how would we map something like <tt>std::regex_error</tt>, or <tt>std::bad_variant_access</tt>?
In the proposed mapping above, an <tt>std::regex_error</tt>, which inherits from <tt>std::runtime_error</tt>, would be mapped to 
<tt>errc::resource_unavailable_try_again</tt>, which conveys no actual useful information about the original error.
</p>
<h2>POSIX != generic</h2>
<p>
A wider concern here is that we are probably wrongly assuming that the <tt>std::errc</tt> enums really constitute a set of truly "generic" error codes.  This assumption is
understandable since, after all, these error codes are lifted from POSIX and are designed to provide portability, which is why <tt>std::errc</tt> codes are used with <tt>std::generic_category</tt> in <tt>&lt;system_error&gt;</tt>.  But the reality is the POSIX error codes that the <tt>std::errc</tt> enums map to were devised with the
goal of defining a set of generic error codes that might usefully map to the sort of errors that an <i>Operating System API</i>
might produce.  As a set of generic <i>system</i> error codes, POSIX seems to have provided a useful set of mostly portable codes for <tt>&lt;system_error&gt;</tt> to adopt.  But
again these codes were lifted from <i>Operating System API</i> errors - <i>not</i> generic application errors.  These codes include error conditions for circumstances
that are completely beyond the scope of the current C++ standard, such as <tt>std::errc::broken_pipe</tt> and <tt>std::errc::inappropriate_io_control_operation</tt>.
</p>
<p>
Of course, the intention of <tt>&lt;system_error&gt;</tt> was never to provide a set of truly <i>generic</i> error codes - it was to provide a set of generic <i>system</i>
error codes that could be portably communicated in standard C++.  In that capacity, using the POSIX error codes for <tt>std::errc</tt> was a very reasonable choice.
But regardless, <tt>&lt;system_error&gt;</tt> is not meant to provide a set of "generic" application-level error conditions, and so this family of error codes
is probably not suitable for mapping <i>application-level</i> errors, the very type of errors that standard C++ dynamic exceptions represent.  A hypothetical set of error codes that represent 
truly generic <i>application</i> errors would look more like what we get in <tt>&lt;stdexcept&gt;</tt>:  maybe something like <tt>generic_errc::runtime_error</tt>,
<tt>generic_errc::out_of_range</tt>, <tt>generic_errc::size_too_large</tt>, etc.  This is the same sort of "generic error" taxonomy found in typical
standard exception libraries across many languages, such as Python's builtin <tt>RuntimeError</tt>, <tt>OverflowError</tt>, <tt>IndexError</tt>, etc.  A set 
of generic error codes mapping to C++ exceptions should probably look more like this and less like something that includes <tt>inappropriate_io_control_operation</tt> and <tt>bad_file_descriptor</tt>.
<p>
To the extent that the concerns of an Operating System API are likely to overlap with the concerns of a user-level application (mostly within the domain of argument 
validation)
we can find meaningful mappings from <tt>&lt;system_error&gt;</tt> to standard C++ exceptions.  But beyond that, it becomes a real stretch, where much less useful 
information is conveyed by the error code.  Since <tt>std::error</tt> is clearly meant as "one error type to rule them all" - as the eventual
successor of both <tt>std::error_code</tt> and dynamic exceptions in general, it seems we clearly need something a lot broader than <tt>&lt;system_error&gt;</tt>
to use as a family of "generic" error codes.  The current <tt>status_code</tt> based implementation of <tt>std::error</tt> proposed in 
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1028r3.pdf">P1028</a>] reuses the <tt>std::errc</tt> codes (with one slight modification), and
expects all error domains to be able to map errors to one of these "generic" codes.  But for many error domains there simply isn't anything useful in POSIX to map
to.  How again do we map an <tt>std::regex_error</tt> to a POSIX code?  Do we just use <tt>errc::invalid_argument</tt> or something and give up on providing any 
meaningful mapping?
</p>
<p>
I would suggest two things: firstly, to review the idea that every possible <tt>std::error</tt> domain is to be expected to usefully map to some "universal"
set of generic error codes in the first place.  I argue that this requirement is likely to be impractical for many error domains, and if enforced would 
simply lead to many useless error mappings that convey next to zero actual information about the semantics of the original error.
<p>
Secondly, if we do want to provide something like a set of "universal" generic error codes that any error domain could feasibly map to,
<i>and</i> if we also want to have a set of error codes available that enables useful weak-equality comparisons with an <tt>std::error</tt> 
that stores an <tt>std::exception_ptr</tt>, we would probably want to define a new, more universal set of error code enums that are not specifically
designed for Operating System API errors.
</p>
<p>
The approach submitted here (and used in the submitted implementation) is to firstly define a set of error code enums specifically meant to represent all standard
dynamic exceptions.  Note that many standard exceptions are de-facto equivalent to an error code enum, in the sense that they convey no information other
then their <i>type</i> and a static message.  For example, <tt>std::bad_variant_access</tt> or <tt>std::bad_cast</tt> (or any other exception type that provides
only a default constructor, copy constructor, and static <tt>what()</tt> message), convey no information beyond their type and the static message associated with
their type.  Thus they are representable as semantically equivalent error codes with zero loss of information.  Other exception types (such as <tt>std::runtime_error</tt>) take
a per-instance message string, and so cannot be represented as an error code without information loss.  However, since <tt>std::error</tt> can store an 
<tt>std::exception_ptr</tt> which can convey the per-instance message, there is no problem here.  Regardless, mapping all standard exceptions to a special set of
dynamic exception error codes may be useful in bridging dynamic exceptions and static errors, especially with regard to weak-equality testing.  These dynamic exception
error code enums may look something like the following:

<blockquote>
<pre>
<span style="font-weight:bold">enum class</span> dynamic_exception_errc
{
   <tt>runtime_error</tt>,
   <tt>domain_error</tt>,
   <tt>invalid_argument</tt>,
   <tt>length_error</tt>,
   <tt>out_of_range</tt>,
   <tt>range_error</tt>,
   <tt>overflow_error</tt>,
   <tt>underflow_error</tt>,
   <tt>system_error</tt>,
   <tt>bad_alloc</tt>,
   <tt>bad_array_new_length</tt>,
   <tt>bad_optional_access</tt>,
   <tt>bad_typeid</tt>,
   <tt>bad_any_cast</tt>,
   <tt>regex_error</tt>,
   <tt>bad_cast</tt>,
   <tt>bad_weak_ptr</tt>,
   <tt>bad_exception</tt>,
   <tt>bad_variant_access</tt>,
   <tt>unspecified_exception</tt>
};
</pre>
</blockquote>
<p>
This would specifically map dynamic exceptions to a set of error codes that could be usefully employed to test for weak equality.
On top of this, I would also suggest providing a set of truly "generic" application level error code enums, perhaps using the
enum class "generic_errc".  Ideally, <tt>std::errc</tt> would have been named <tt>std::posix_errc</tt> - however, again <tt>&lt;system_error&gt;</tt>
was designed foremost within the context of the Operating System error domain, and was probably not initially conceived of with generic application 
level error codes in mind.
</p>
<p>
Defining a set of generic application level error codes is beyond the scope of this paper, and the submitted implementation does not even attempt
this.  However, a hypothetical set of generic error codes would probably look something like the above list of dynamic_exception error codes.  As such,
a better approach may simply be to get rid of the idea of a separate <tt>dynamic_exception_errc</tt> set of codes and just make these the generic 
codes.  Domains that have more specific error-reporting requirements, such as <tt>std::regex_error</tt> could also implement separate <tt>error_domain</tt>s.
</p>
<h2>The submitted std::error implementation</h2>
The submitted <tt>std::error</tt> implementation is not meant to represent a formal proposal, but to serve as a hopefully useful contribution and alternative
reference implementation of <tt>std::error</tt> that can assist with design discussions going forward.  It also serves as a suggested minimal interface for
<tt>std::error</tt> and associated types.  The submitted implementation supports all the requirements
laid out in [<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0709r4.pdf">P0709</a>], namely:
<ol>
<li><tt>std::error</tt> always represents a failure</tt></li>
<li><pre><b>sizeof</b>(<tt>std::error</tt>) == <b>sizeof</b>(std::<tt>intptr_t</tt>) * 2</pre></li>
<li><pre>It uses <tt>constexpr</tt> error_domain discriminants to implement polymorphic behavior</pre></li>
<li><pre>It is able to represent all causes of failure within the C++ standard library</pre></li>
<li><pre>It is type-erased, allocation-free, and trivially-relocatable</pre></li>
<li><pre>It can be used in a header-only library (unlike <tt>std::error_category</tt>)</pre></li>
<li>It has a <tt>==</tt> operator that provides weak-equality comparison (semantic-equivalence)</li>
</ol>
<p>
The submitted implementation includes an opt-in <tt>is_trivially_relocatable</tt> trait that enables <tt>std::exception_ptr</tt>
to be stored directly within an <tt>std::error</tt> without an additional allocation (provided the implementation of <tt>std::exception_ptr</tt>
is only one pointer in size, such as the libstdc++ implementation shipped with GCC).
</p>
<h4>Differences with the status_code library implementation proposed in [P1028]:</h4>
The submitted implementation differs with the current <tt>status_code</tt> based implementation proposed in
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1028r3.pdf">P1028</a>] as follows:

<ol>
<li>This implementation is a stand-alone implementation of <tt>std::error</tt> - it does not implement any larger status code or error code library</li>
<li>This implementation makes <tt>std::error</tt> copy-constructible instead of move-only</li>
<li>This implementation does not require all error domains to be able to map errors to a universal "generic" error code</li>
<li>For the purpose of providing error code enums used for weak-equality comparisons with <tt>std::error</tt> objects containing a thrown dynamic exception,
this implementation defines a new <tt>dynamic_exception_errc</tt> enum class.  (It also supports semantic comparison with <tt>std::errc</tt> such that, e.g. a thrown <tt>std::invalid_argument</tt> will compare semantically equivalent to an <tt>std::errc::invalid_argument</tt>, but for the reasons discussed above I 
consider <tt>std:errc</tt> to be inadequate for serving as a set of universal generic error codes.)</li>
<li>ErrorDomain ID's are 128-bit integers instead of 64-bit.  With 64-bit, the chance of a collision approaches 50% when you reach about ~4 billion randomly generated 
error domain IDs. While it's obviously absurdly unlikely any single application will ever have that many error domains, consider a future where 
distributed applications send serialized <tt>std::error</tt> objects over the wire.  In this case domain IDs should be globally unique, so 128-bit 
is probably more appropriate.</li>
</ol>

<p>
With regard to the weak-equality comparison algorithm, this implementation submits a simpler algorithm than the algorithm implemented in 
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1028r3.pdf">P1028</a>].  The algorithm implemented in 
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1028r3.pdf">P1028</a>] is as follows:

<blockquote>
<pre>
Given: <tt>error</tt> <span class="e1">E1</span> with <tt>error_domain</tt> <span class="e1">D1</span>, and <tt>error</tt> <span class="e2">E2</span> with <tt>error_domain</tt> <span class="e2">D2</span>

If both <span class="e1">D1</span> and <span class="e2">D2</span> are non-null:
   If <span class="e1">D1</span>.<tt>WeakEqualityCompare</tt>(<span class="e1">E1</span>, <span class="e2">E2</span>): return <tt>true</tt>
   Else If <span class="e2">D2</span>.<tt>WeakEqualityCompare</tt>(<span class="e2">E2</span>, <span class="e1">E1</span>): return <tt>true</tt>
   Else:
      Convert <span class="e2">E2</span> to <Tt>GenericCode</tt> <span class="e2">G2</span>
      If <span class="e1">D1</span>.<tt>WeakEqualityCompare</tt>(<span class="e1">E1</span>, <span class="e2">G2</span>): return <tt>true</tt>

      Convert <span class="e1">E1</span> to <tt>GenericCode</tt> <span class="e1">G1</span>
      If <span class="e2">D2</span>.<tt>WeakEqualityCompare</tt>(<span class="e2">E2</span>, <span class="e1">G1</span>): return <tt>true</tt>

Return <tt>true</tt> if both <span class="e1">D1</span> and <span class="e2">D2</span> are null
</pre>
</blockquote>

<p>
Note this algorithm requires error domains to implement conversion from some arbitrary error type to a universal set of "generic" errors (specified in 
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1028r3.pdf">P1028</a>] as identical to the POSIX error codes defined in <tt>&lt;system_error&gt;</tt>).  
The implementation submitted here does not require that all error types must be representable by a single set of generic codes.  I have argued 
that this is very likely impractical for certain error domains, and if enforced would merely lead to many useless mappings to "generic" codes that convey close to zero
information about the semantics of the original error.
</p>
<p>
Additionally, the implementation submitted here does not permit an error object to have a <tt>nullptr</tt> for
an error_domain.  In [<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1028r3.pdf">P1028</a>], <tt>error</tt> objects are move-only and therefore
a "moved-from" <tt>error</tt> has a null domain pointer.  However, <tt>error</tt> objects in this implementation are copy-constructible; errors that transport
non-trivially-copyable or non-trivially-movable types will provide polymorphic move and copy constructors.  It is up to the domain-specific move constructor to
decide how to represent a "moved-from" type-erased error value internally.  Therefore, there is no reason to allow an error object to contain a null domain pointer.
</p>
<p>
With null domain pointers disallowed, and without the requirement that all error domains provide a mapping to a set of universal generic error codes, 
the weak-equality comparison algorithm implemented here is simply:
</p>
<blockquote>
<pre>
Given: <tt>error</tt> <span class="e1">E1</span> with <tt>error_domain</tt> <span class="e1">D1</span>, and <tt>error</tt> <span class="e2">E2</span> with <tt>error_domain</tt> <span class="e2">D2</span>

If <span class="e1">D1</span>.<tt>WeakEqualityCompare</tt>(<span class="e1">E1</span>, <span class="e2">E2</span>): return <tt>true</tt>
Else If <span class="e2">D2</span>.<tt>WeakEqualityCompare</tt>(<span class="e2">E2</span>, <span class="e1">E1</span>): return <tt>true</tt>
return <tt>false</tt>
</pre>
</blockquote>
</p>
<p>
<h4>A minimal std::error specification</h4>
The most significant types specified here are the <tt>error</tt> type itself, along with the <tt>error_domain</tt> abstract base type:
</p>
<blockquote>
<pre>
<b>class</b> error_domain
{
<b>public</b>:
   <tt>constexpr</tt> error_domain_id id() <tt>const</tt> <b>noexcept</b>;

   <b>virtual</b> string_ref name() <tt>const</tt> <b>noexcept</b> = 0;
   <b>virtual</b> <tt>bool</tt> equivalent(<tt>const</tt> error& lhs, <tt>const</tt> error& rhs) <tt>const</tt> <b>noexcept</b> = 0;
   <b>virtual</b> string_ref message(<tt>const</tt> error&) const <b>noexcept</b> = 0;
   <b>virtual</b> <tt>void</tt> throw_exception(<tt>const</tt> error& e) <tt>const</tt>;

<b>protected</b>:
   <tt>constexpr</tt> <b>explicit</b> error_domain(error_domain_id id) <b>noexcept</b>;

   <tt>constexpr</tt> error_domain(error_domain_id id, error_resource_management erm) <b>noexcept</b>;

   error_domain(<tt>const</tt> error_domain&) = <b>default</b>;
   error_domain(error_domain&&) = <b>default</b>;
   error_domain& <b>operator</b> = (<tt>const</tt> error_domain&) = <b>default</b>;
   error_domain& <b>operator</b> = (error_domain&&) = <b>default</b>;
   ~error_domain() = <b>default</b>;
};

<tt>constexpr</tt> <tt>bool</tt> <b>operator</b> == (<tt>const</tt> error_domain& lhs, <tt>const</tt> error_domain& rhs) <b>noexcept</b>;
<tt>constexpr</tt> <tt>bool</tt> <b>operator</b> != (<tt>const</tt> error_domain& lhs, <tt>const</tt> error_domain& rhs) <b>noexcept</b>;

<span style='color:gray'>// Exposition only</span>
<b>template</b> &lt;<b>class</b> T&gt;
<b>concept</b> TypeErasable = is_trivially_relocatable_v&lt;T&gt; && (<b>sizeof</b>(T) &lt;= <b>sizeof</b>(std::<tt>intptr_t</tt>));

<b>class</b> error
{
<b>public</b>:
   <tt>constexpr</tt> error() <b>noexcept</b>;
   <tt>constexpr</tt> error(const error& e);
   <tt>constexpr</tt> error(error&& e);

   <b>template</b> &lt;<b>class</b> T&gt; <b>requires</b> TypeErasable&lt;T&gt;
   <tt>constexpr</tt> error(<tt>const</tt> error_value&lt;T&gt;& v, <tt>const</tt> error_domain& d) <b>noexcept</b>;

   <b>template</b> &lt;<b>class</b> T&gt; <b>requires</b> TypeErasable&lt;T&gt;
   <tt>constexpr</tt> error(error_value&lt;T&gt;&& v, <tt>const</tt> error_domain& d) <b>noexcept</b>;

   <tt>constexpr</tt> error(error_value&lt;&gt; v, <tt>const</tt> error_domain& d) <b>noexcept</b>;

   <b>template</b> &lt;<b>class</b> A, <b>class</b>... Args&gt;
      <b>requires</b> <span style='color:gray'>/* make_error((A&&)a, (Args&&)args...) via ADL returns an error object */</span>
   <tt>constexpr</tt> error(A&& a, Args&&... args) <b>noexcept</b>(<span style='color:gray'>/* unspecified */</span>);

   error& <b>operator</b> = (<tt>const</tt> error& e);
   error& <b>operator</b> = (error&& e) <b>noexcept</b>;
   ~error();

   <tt>const</tt> error_domain& domain() <tt>const</tt> <b>noexcept</b>;

   string_ref message() <tt>const</tt> <b>noexcept</b>;

   <tt>[[noreturn]]</tt> <tt>void</tt> throw_exception() <tt>const</tt>;
};

bool <b>operator</b> == (<tt>const</tt> error& lhs, <tt>const</tt> error& rhs) <b>noexcept</b>;
bool <b>operator</b> != (<tt>const</tt> error& lhs, <tt>const</tt> error& rhs) <b>noexcept</b>;
</pre>
</blockquote>

<p>
We also define class template <tt>error_value</tt> as a mechanism for constructing an <tt>error</tt> object from 
a TypeErasable object and an error_domain.  
<blockquote>
<pre>
<span style='color:gray'>// Transports a type-erasable object of type T</span>
<b>template</b> &lt;<b>class</b> T = <tt>void</tt>&gt;
<b>class</b> error_value
{
<b>public:</b>
   <b>using</b> value_type = T;

   <tt>constexpr</tt> error_value(<tt>const</tt> T& v) <b>noexcept</b>(
      std::is_nothrow_copy_constructible_v&lt;T&gt;
   );

   <tt>constexpr</tt> error_value(T&& v) <b>noexcept</b>(
      std::is_nothrow_move_constructible_v&lt;T&gt;
   );

   <tt>constexpr</tt> <tt>const</tt> T& value() <tt>const</tt> & <b>noexcept</b>;
   <tt>constexpr</tt> T& value() & noexcept;
   <tt>constexpr</tt> <tt>const</tt> T&& value() <tt>const</tt> && <b>noexcept</b>;
   <tt>constexpr</tt> T&& value() && <b>noexcept</b>;
};

<span style='color:gray'>// Type-erasing specialization: type erases and transports a type-erased object</span>
<b>template</b> &lt;&gt;
<b>class</b> error_value&lt;<tt>void</tt>&gt;
{
<b>public</b>:
   <b>template</b> &lt;<b>class</b> T&gt; <b>requires</b> TypeErasable&lt;std::remove_cvref_t&lt;T&gt;&gt;
   <tt>constexpr</tt> error_value(T&& v) <b>noexcept</b>(<span style='color:gray'>/* unspecified */</span>);

   <b>template</b> &lt;<b>class</b> T&gt; <b>requires</b> TypeErasable&lt;T&gt;
   <tt>constexpr</tt> error_value(const error_value&lt;T&gt;& v) <b>noexcept</b>(<span style='color:gray'>/* unspecified */</span>);

   <b>template</b> &lt;<b>class</b> T&gt; <b>requires</b> TypeErasable&lt;T&gt;
   <tt>constexpr</tt> error_value(error_value&lt;T&gt;&& v) <b>noexcept</b>(<span style='color:gray'>/* unspecified */</span>)
};
</pre>
</blockquote>
Additionally, an arbitrary type can be made implicitly convertible to
an <tt>error</tt> via the <tt>make_error</tt> ADL-based customization point function.
</p>
<p>
We provide the following free functions for extracting the type-erased object from an <tt>std::error</tt>
instance.  This function is efficient but unsafe, as no type-checking is performed, so it should generally only
be used directly by an <tt>error_domain</tt> object that has information about the erased type.  These functions
only participate in overload resolution if <tt><b>T</b></tt> is <tt>TypeErasable</tt>.
</p>
<blockquote>
<pre>
<span style='color:gray'>// Returns an instance of T that was directly copy-constructed from the internal error storage</span>
<b>template</b> &lt;<b>class</b> T&gt;
<tt>constexpr</tt> T error_cast(<tt>const</tt> error& e) <b>noexcept</b>(<span style='color:gray'>/* unspecified */</span>);

<span style='color:gray'>// Returns an instance of T that was directly move-constructed from the internal error storage</span>
<b>template</b> &lt;<b>class</b> T&gt;
<tt>constexpr</tt> T error_cast(error&& e) <b>noexcept</b>(<span style='color:gray'>/* unspecified */</span>);
</pre>
</blockquote>
<p>
Finally, we define an <tt>error_resource_management</tt> class template that, when passed to an <tt>error_domain</tt>, provides polymorphism for a type-erased error
object's copy-constructor, move-constructor and destructor:
</p>
<blockquote>
<pre>
<b>struct</b> error_resource_management
{
   <b>using</b> copy_constructor = error_value&lt;<tt>void</tt>&gt;(*)(<tt>const</tt> error&);
   <b>using</b> move_constructor = error_value&lt;<tt>void</tt>&gt;(*)(error&&);
   <b>using</b> destructor = <tt>void</tt>(*)(error&);

   <tt>constexpr</tt> error_resource_management() <b>noexcept</b>;
   <tt>constexpr</tt> error_resource_management(copy_constructor cctor, move_constructor mctor, destructor dtor) <b>noexcept</b>;
};
</pre>
</blockquote>

<p>For convenience, we provide a default error_resource_management variable template which simply uses the copy/move constructors,
as well as the destructor, for some arbitrary type T:</p>

<blockquote>
<pre>
<b>template</b> &lt;<b>class</b> T&gt;
<tt>inline</tt> <tt>constexpr</tt> default_error_resource_management_t&lt;T&gt; default_error_resource_management {};
</pre>
</blockquote>

<p>The <tt>default_error_resource_management_t</tt> class must behave <i>as if</i> it was implemented as follows:</tt>

<blockquote>
<pre>
<b>namespace</b> detail {

   <b>struct</b> default_error_constructors
   {
      <b>template</b> &lt;<b>class</b> T&gt;
      <b>static</b> error_value<> copy_constructor(<tt>const</tt> error& e)
      {
         T value = error_cast&lt;T&gt;(e);
         <b>return</b> error_value&lt;&gt;{std::move(value)};
      }

      <b>template</b> &lt;<b>class</b> T&gt;
      <b>static</b> error_value<> move_constructor(error&& e)
      {
         <b>return</b> error_value<>{error_cast&lt;T&gt;(std::move(e))};
      }

      <b>template</b> &lt;<b>class</b> T&gt;
      <b>static</b> <tt>void</tt> destructor(error& e) <b>noexcept</b>
      {
         <span style='color:gray'><i>unspecified_erased_error_ref</i></span> value = <span style='color:gray'>/* unspecified: get reference to internal storage */</span>
         std::launder(<b>reinterpret_cast</b>&lt;T*&gt;(&value.storage))-&gt;~T();
      }

      <b>template</b> &lt;<b>class</b> T&gt;
      <tt>constexpr</tt> <b>static</b> error_resource_management::copy_constructor copy() <b>noexcept</b>
      {
         <b>return</b> std::is_trivially_copy_constructible_v&lt;T&gt; ?
            <tt>nullptr</tt> : &amp;copy_constructor&lt;T&gt;;
      }

      <b>template</b> &lt;<b>class</b> T&gt;
      <tt>constexpr</tt> <b>static</b> error_resource_management::move_constructor move() <b>noexcept</b>
      {
         <b>return</b> std::is_trivially_move_constructible_v&lt;T&gt; ?
            <tt>nullptr</tt> : &move_constructor&lt;T&gt;;
      }

      <b>template</b> &lt;<b>class</b> T&gt;
      <tt>constexpr</tt> <b>static</b> error_resource_management::destructor destroy() <b>noexcept</b>
      {
         <b>return</b> std::is_trivially_destructible_v&lt;T&gt; ?
            <tt>nullptr</tt> : &destructor&lt;T&gt;;
      }
   };
} // end namespace detail

<b>template</b> &lt;<b>class</b> T&gt;
<b>struct</b> default_error_resource_management_t : error_resource_management
{
   <tt>constexpr</tt> default_error_resource_management_t() <b>noexcept</b>
      : 
      error_resource_management{
         detail::default_error_constructors::copy&lt;T&gt;(),
         detail::default_error_constructors::move&lt;T&gt;(),
         detail::default_error_constructors::destroy&lt;T&gt;()
      }
   {}
};
</pre>
</blockquote>
<p>
As with the <tt>status_code</tt>-based implementation proposed in
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1028r3.pdf">P1028</a>], a <tt>string_ref</tt>
type along with a reference-counted shared-ownership version (here called <tt>shared_string_ref</tt>) is provided for error messages.
</p>

<p>
The submitted implementation defines the following <tt>error_domain</tt>s: 

<blockquote>
<ul>
<li>
<b>generic_domain</b> : transports an <tt>std::errc</tt>, supports weak-equality comparison with <tt>std::errc</tt>, <tt>dynamic_exception_errc</tt>, <tt>std::error_code</tt> or 
an <tt>error</tt> object transporting any of these or an <tt>error</tt> object transporting an <tt>std::exception_ptr</tt>.
</li>

<li>
<b>error_code_domain</b> : transports an <tt>std::error_code</tt>, supports weak-equality comparison to <tt>std::error_code</tt>, <tt>std::errc</tt>, or an <tt>error</tt> 
object transporting any of these or an error object transporting an <tt>std::exception_ptr</tt>
</li> 

<li>
<b>dynamic_exception_domain</b> : stores an <tt>std::exception_ptr</tt>, supports weak-equality comparison with <tt>dynamic_exception_errc</tt>, <tt>std::errc</tt>, <tt>std::error_code</tt>, or an <tt>error</tt> object transporting any of these or an <tt>error</tt> object transporting an <tt>std::exception_ptr</tt>.
</li>
<b>dynamic_exception_code_domain</b> : stores a <tt>dynamic_exception_errc</tt>, supports weak-equality comparison with <tt>dynamic_exception_errc</tt>, <tt>std::errc</tt>, <tt>std::error_code</tt> 
or an <tt>error</tt> object transporting any of these or an error object transporting an <tt>std::exception_ptr</tt>.
</ul>
</blockquote>
</p>
<p>
Per the above discussion of POSIX error codes as insuitable for a generic error mechanism, I would alternatively propose that <tt>generic_domain</tt> be changed to <tt>posix_domain</tt>, and <tt>dynamic_exception_code_domain</tt> be reworked into an error_domain for generic application-level error codes, including individual codes
for each standard C++ exception type.  Additionally, I would propose including <tt>system_domain</tt> which, similarly to the current <tt>std::system_category</tt>, transports error codes returned from an Operating System API and provides semantic comparison to the portable set of POSIX errors defined in <tt>std::errc</tt>.
</p>
<br>
<br>
-Charles Salvia, csalvia@bloomberg.net
</body></html>

